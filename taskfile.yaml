version: "3"

vars:
  # All Go source files (excluding vendor)
  GO_FILES:
    sh: find . -type f -name '*.go' -not -path "./vendor/*"
  # Package list for analysis scoped to project sources
  GO_PKGS:
    sh: go list ./src/...

tasks:
  default:
    desc: Run default checks (fmt, lint, test)
    cmds:
      - task: fmt
      - task: lint
      - task: test

  install-tools-mac:
    desc: Install all required Go tools on macOS
    cmds:
      - brew install hadolint
      - brew install golangci-lint
      - brew install aquasecurity/trivy/trivy
      - brew install tinygo
      - brew install protoc-gen-go
      - brew install protoc-gen-go-grpc
      - go install github.com/google/go-licenses/v2@latest
      - go install github.com/sandrolain/eventkit/...@latest
      - go install github.com/sandrolain/goncurrently@latest
      - go install github.com/golangci/golangci-lint/v2/cmd/golangci-lint@v2
      - asdf reshim

  fmt-check:
    desc: Check Go code formatting without making changes
    cmds:
      - echo "Running gofmt..."
      - gofmt -d -e -l -s .

  fmt:
    desc: Format Go code with simplification
    cmds:
      - echo "Running gofmt..."
      - gofmt -s -l -w .

  lint:
    desc: Run golangci-lint across the codebase
    cmds:
      - echo "Running golangci-lint..."
      - golangci-lint run

  hadolint:
    desc: Run hadolint on Dockerfile
    cmds:
      - echo "Running hadolint on Dockerfile..."
      - hadolint docker/Dockerfile

  build-wasm-test-assets:
    desc: Build WASM test assets for unit tests
    dir: ./src/connectors/wasm/testassets
    cmds:
      - echo "Building WASM test assets..."
      - GOOS=wasip1 GOARCH=wasm go build -o testrunner.wasm testrunner.go
      - GOOS=wasip1 GOARCH=wasm go build -o errorrunner.wasm errorrunner.go
      - GOOS=wasip1 GOARCH=wasm go build -o timeoutrunner.wasm timeoutrunner.go
      - echo "WASM test assets built successfully"
      - du -h *.wasm

  clean-wasm-test-assets:
    desc: Clean WASM test assets
    dir: ./src/connectors/wasm/testassets
    cmds:
      - echo "Cleaning WASM test assets..."
      - rm -f *.wasm

  build-plugin-test-asset:
    desc: Build test plugin asset for plugin connector unit tests
    dir: ./src/connectors/plugin/testassets
    cmds:
      - echo "Building test plugin asset for connector tests..."
      - go build -o test-plugin-connector testplugin.go && du -h test-plugin-connector

  build-goplugin-test-asset:
    desc: Build test plugin asset for plugin connector unit tests using Go plugin mode
    dir: ./src/utils/testdata/testplugin
    cmds:
      - echo "Building test plugin asset for connector tests (plugin mode)..."
      - go build -buildmode=plugin -o testplugin.so plugin.go && du -h testplugin.so

  clean-plugin-test-assets:
    desc: Clean test assets
    dir: ./src/connectors/plugin/testassets
    cmds:
      - echo "Cleaning test assets..."
      - rm -f test-plugin-connector

  test:
    desc: Run tests with race detector and coverage (suppress linker warnings)
    deps:
      - build-wasm-test-assets
      - build-plugin-test-asset
    cmds:
      - echo "Running tests with coverage (clean output)..."
      - |
        set -o pipefail
        go test -coverprofile=coverage.out -covermode=atomic ./src/... 2>&1 | \
        grep -v "ld: warning.*malformed LC_DYSYMTAB" || \
        (test ${PIPESTATUS[0]} -eq 0)
      - go tool cover -html=coverage.out -o coverage.html
      - echo "Coverage report generated at coverage.html"

  test-verbose:
    desc: Run tests with race detector and coverage (show all output including warnings)
    deps:
      - build-wasm-test-assets
      - build-plugin-test-asset
    cmds:
      - echo "Running tests with coverage (verbose mode)..."
      - go test -race -coverprofile=coverage.out -covermode=atomic ./src/...
      - go tool cover -html=coverage.out -o coverage.html
      - echo "Coverage report generated at coverage.html"

  test-integration:
    desc: Run integration tests using testcontainers
    cmds:
      - echo "Running Kafka integration tests..."
      - cd ./src/connectors/kafka && go test -tags=integration -v -timeout=120s
      - echo "Running Redis integration tests..."
      - cd ./src/connectors/redis && go test -tags=integration -v -timeout=60s
      - echo "Running PostgreSQL integration tests..."
      - cd ./src/connectors/pgsql && go test -tags=integration -v -timeout=120s
      - echo "All integration tests completed successfully!"

  trivy:
    desc: Run Trivy filesystem scanner (vuln, secret, misconfig)
    vars:
    cmds:
      - echo "Running Trivy vulnerability scanner..."
      - trivy fs --scanners vuln,secret,misconfig .
      - trivy fs --format json --output trivy-results.json .

  licenses:
    desc: Check for forbidden licenses (GPL-like) and export CSV report
    cmds:
      - echo "Checking for forbidden licenses (GPL, LGPL, AGPL)..."
      - |
        go-licenses check ./src/... \
          --disallowed_types=GPL-2.0,GPL-3.0,LGPL-2.0,LGPL-2.1,LGPL-3.0,AGPL-1.0,AGPL-3.0 \
          || echo "⚠️  WARNING: Found forbidden licenses!"
      - echo "Generating CSV license report..."
      - go-licenses csv ./src/... > licenses.csv
      - echo "✅ License report saved to licenses.csv"
      - echo "Review licenses.csv to verify all dependencies"

  check:
    desc: Run all checks (fmt, lint, test, trivy, licenses)
    cmds:
      - task: fmt
      - task: lint
      - task: trivy
      - task: test
      - task: licenses
      - task: hadolint

  install-deps:
    desc: Install and tidy Go module dependencies
    cmds:
      - go mod download
      - go mod tidy

  clean:
    desc: Clean build and analysis artifacts
    cmds:
      - go clean -cache -testcache -modcache
      - rm -rf bin/
      - rm -rf dist/
      - rm -f coverage.out
      - rm -f coverage.html
      - rm -f security-report.json
      - rm -f trivy-results.json
      - rm -f licenses.csv
      - task: clean-wasm-test-assets
      - task: clean-plugin-test-assets

  rebuild:
    desc: Clean and then build everything
    cmds:
      - task: clean
      - task: build

  build:
    cmds:
      - mkdir -p ./bin/connectors
      - mkdir -p ./bin/runners
      - |
        echo "Building connector plugins..."
        for d in ./src/connectors/*; do
          [ -d "$d" ] || continue
        name="$(basename "$d")"
        out="./bin/connectors/${name}.so"
        go build -buildmode=plugin -o "$out" "$d" && du -h "$out"
        done
      - go build -o ./bin/events-bridge ./src  && du -h ./bin/events-bridge

  gen-plugin-proto:
    dir: ./src/connectors/plugin/proto
    cmds:
      - protoc --proto_path=. --go_out=. --go_opt=paths=source_relative --go-grpc_out=. --go-grpc_opt=paths=source_relative ./plugin.proto

  rebuild-testers:
    desc: Clean and then build testers and tools
    dir: ./testers
    cmds:
      - rm -rf ./bin
      - task: build-testers

  build-testers:
    dir: ./testers
    cmds:
      - echo "Building testers..."
      - |
        echo "Building tools..."
        for d in ./tools/*; do
          [ -d "$d" ] || continue
          name="$(basename "$d")"
          out="./bin/${name}"
          go build -o "$out" "$d" && du -h "$out"
        done
      - echo "Building test plugin..."
      - go build -o ./bin/plugin ./runners/plugin && du -h ./bin/plugin
      - echo "Building test wasm..."
      #- tinygo build -o ./bin/wasmrunner.wasm -target=wasi ./runners/wasmrunner && du -h ./bin/wasmrunner.wasm
      - GOOS=wasip1 GOARCH=wasm go build -o ./bin/wasmrunner.wasm ./runners/wasmrunner && du -h ./bin/wasmrunner.wasm

  run:*:
    desc: Run a specified task (e.g., run-mqtt-to-http)
    vars:
      CONFIG_NAME: "{{index .MATCH 0}}"
    cmds:
      - cat ./testers/config/{{.CONFIG_NAME}}.yaml | goncurrently

  docker-build:
    desc: Build Docker image for events-bridge
    vars:
      IMAGE_NAME: '{{default "events-bridge" .IMAGE_NAME}}'
      IMAGE_TAG: '{{default "latest" .IMAGE_TAG}}'
    cmds:
      - echo "Building Docker image {{.IMAGE_NAME}}:{{.IMAGE_TAG}}..."
      - docker build -f docker/Dockerfile -t {{.IMAGE_NAME}}:{{.IMAGE_TAG}} .
      - echo "✅ Docker image built successfully"
      - docker images | grep {{.IMAGE_NAME}}

  docker-build-multiarch:
    desc: Build multi-architecture Docker image (linux/amd64, linux/arm64)
    vars:
      IMAGE_NAME: '{{default "events-bridge" .IMAGE_NAME}}'
      IMAGE_TAG: '{{default "latest" .IMAGE_TAG}}'
    cmds:
      - echo "Building multi-architecture Docker image {{.IMAGE_NAME}}:{{.IMAGE_TAG}}..."
      - docker buildx create --use --name events-bridge-builder 2>/dev/null || true
      - docker buildx build --platform linux/amd64,linux/arm64 -f docker/Dockerfile -t {{.IMAGE_NAME}}:{{.IMAGE_TAG}} . --push
      - echo "✅ Multi-architecture Docker image built and pushed successfully"

  docker-run:
    desc: Run Docker container locally with example config
    vars:
      IMAGE_NAME: '{{default "events-bridge" .IMAGE_NAME}}'
      IMAGE_TAG: '{{default "latest" .IMAGE_TAG}}'
      CONFIG_PATH: '{{default "./docker/config/config.yaml" .CONFIG_PATH}}'
    cmds:
      - echo "Running Docker container {{.IMAGE_NAME}}:{{.IMAGE_TAG}}..."
      - |
        docker run --rm -it \
          -v $(pwd)/docker/config:/app/config:ro \
          -p 8080:8080 \
          {{.IMAGE_NAME}}:{{.IMAGE_TAG}}

  docker-compose-up:
    desc: Start services using docker-compose
    dir: ./docker
    cmds:
      - echo "Starting services with docker-compose..."
      - docker-compose up -d
      - echo "✅ Services started successfully"
      - docker-compose ps

  docker-compose-down:
    desc: Stop services using docker-compose
    dir: ./docker
    cmds:
      - echo "Stopping services with docker-compose..."
      - docker-compose down
      - echo "✅ Services stopped successfully"

  docker-compose-logs:
    desc: View docker-compose logs
    dir: ./docker
    cmds:
      - docker-compose logs -f events-bridge

  docker-push:
    desc: Push Docker image to registry
    vars:
      IMAGE_NAME: '{{default "events-bridge" .IMAGE_NAME}}'
      IMAGE_TAG: '{{default "latest" .IMAGE_TAG}}'
      REGISTRY: '{{default "" .REGISTRY}}'
    cmds:
      - |
        if [ -n "{{.REGISTRY}}" ]; then
          echo "Tagging image for registry {{.REGISTRY}}..."
          docker tag {{.IMAGE_NAME}}:{{.IMAGE_TAG}} {{.REGISTRY}}/{{.IMAGE_NAME}}:{{.IMAGE_TAG}}
          echo "Pushing {{.REGISTRY}}/{{.IMAGE_NAME}}:{{.IMAGE_TAG}}..."
          docker push {{.REGISTRY}}/{{.IMAGE_NAME}}:{{.IMAGE_TAG}}
          echo "✅ Image pushed successfully to {{.REGISTRY}}"
        else
          echo "Pushing {{.IMAGE_NAME}}:{{.IMAGE_TAG}}..."
          docker push {{.IMAGE_NAME}}:{{.IMAGE_TAG}}
          echo "✅ Image pushed successfully"
        fi

  k8s-deploy:
    desc: Deploy to Kubernetes
    dir: ./docker
    cmds:
      - echo "Deploying to Kubernetes..."
      - kubectl apply -f kubernetes-manifest.yaml
      - echo "✅ Deployed successfully"
      - kubectl -n events-bridge get pods

  k8s-delete:
    desc: Delete Kubernetes resources
    dir: ./docker
    cmds:
      - echo "Deleting Kubernetes resources..."
      - kubectl delete -f kubernetes-manifest.yaml
      - echo "✅ Resources deleted successfully"

  k8s-logs:
    desc: View Kubernetes pod logs
    cmds:
      - kubectl -n events-bridge logs -f -l app=events-bridge

  k8s-status:
    desc: Check Kubernetes deployment status
    cmds:
      - echo "Checking deployment status..."
      - kubectl -n events-bridge get all
      - kubectl -n events-bridge get configmap
